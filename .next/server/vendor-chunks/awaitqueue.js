"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/awaitqueue";
exports.ids = ["vendor-chunks/awaitqueue"];
exports.modules = {

/***/ "(ssr)/./node_modules/awaitqueue/lib/Logger.js":
/*!***********************************************!*\
  !*** ./node_modules/awaitqueue/lib/Logger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nconst LIB_NAME = 'awaitqueue';\nclass Logger {\n    constructor(prefix) {\n        if (prefix) {\n            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);\n            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);\n            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);\n        }\n        else {\n            this._debug = (0, debug_1.default)(LIB_NAME);\n            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);\n            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);\n        }\n        /* eslint-disable no-console */\n        this._debug.log = console.info.bind(console);\n        this._warn.log = console.warn.bind(console);\n        this._error.log = console.error.bind(console);\n        /* eslint-enable no-console */\n    }\n    get debug() {\n        return this._debug;\n    }\n    get warn() {\n        return this._warn;\n    }\n    get error() {\n        return this._error;\n    }\n}\nexports.Logger = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvTG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLEdBQUcsT0FBTztBQUNyRSxpREFBaUQsU0FBUyxRQUFRLE9BQU87QUFDekUsa0RBQWtELFNBQVMsU0FBUyxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFELGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9rZW1vbi1nYW1lLWV0aGluZGlhLTEvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvTG9nZ2VyLmpzPzE0MzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBMSUJfTkFNRSA9ICdhd2FpdHF1ZXVlJztcbmNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7TElCX05BTUV9OiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpXQVJOOiR7cHJlZml4fWApO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06RVJST1I6JHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKExJQl9OQU1FKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06V0FSTmApO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06RVJST1JgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIHRoaXMuX2RlYnVnLmxvZyA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH1cbiAgICBnZXQgZGVidWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1ZztcbiAgICB9XG4gICAgZ2V0IHdhcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXJuO1xuICAgIH1cbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/awaitqueue/lib/Logger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(ssr)/./node_modules/awaitqueue/lib/Logger.js\");\nconst logger = new Logger_1.Logger();\n/**\n * Custom Error derived class used to reject pending tasks once stop() method\n * has been called.\n */\nclass AwaitQueueStoppedError extends Error {\n    constructor(message) {\n        super(message ?? 'AwaitQueue stopped');\n        this.name = 'AwaitQueueStoppedError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueStoppedError);\n        }\n    }\n}\nexports.AwaitQueueStoppedError = AwaitQueueStoppedError;\n/**\n * Custom Error derived class used to reject pending tasks once removeTask()\n * method has been called.\n */\nclass AwaitQueueRemovedTaskError extends Error {\n    constructor(message) {\n        super(message ?? 'AwaitQueue task removed');\n        this.name = 'AwaitQueueRemovedTaskError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);\n        }\n    }\n}\nexports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;\nclass AwaitQueue {\n    constructor() {\n        // Queue of pending tasks (map of PendingTasks indexed by id).\n        this.pendingTasks = new Map();\n        // Incrementing PendingTask id.\n        this.nextTaskId = 0;\n        // Whether stop() method is stopping all pending tasks.\n        this.stopping = false;\n    }\n    get size() {\n        return this.pendingTasks.size;\n    }\n    async push(task, name) {\n        name = name ?? task.name;\n        logger.debug(`push() [name:${name}]`);\n        if (typeof task !== 'function') {\n            throw new TypeError('given task is not a function');\n        }\n        if (name) {\n            try {\n                Object.defineProperty(task, 'name', { value: name });\n            }\n            catch (error) { }\n        }\n        return new Promise((resolve, reject) => {\n            const pendingTask = {\n                id: this.nextTaskId++,\n                task: task,\n                name: name,\n                enqueuedAt: Date.now(),\n                executedAt: undefined,\n                completed: false,\n                resolve: (result) => {\n                    // pendingTask.resolve() can only be called in execute() method. Since\n                    // resolve() was called it means that the task successfully completed.\n                    // However the task may have been stopped before it completed (via\n                    // stop() or remove()) so its completed flag was already set. If this\n                    // is the case, abort here since next task (if any) is already being\n                    // executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`resolving task [name:${pendingTask.name}]`);\n                    // Resolve the task with the obtained result.\n                    resolve(result);\n                    // Execute the next pending task (if any).\n                    const [nextPendingTask] = this.pendingTasks.values();\n                    // NOTE: During the resolve() callback the user app may have interacted\n                    // with the queue. For instance, the app may have pushed a task while\n                    // the queue was empty so such a task is already being executed. If so,\n                    // don't execute it twice.\n                    if (nextPendingTask && !nextPendingTask.executedAt) {\n                        void this.execute(nextPendingTask);\n                    }\n                },\n                reject: (error) => {\n                    // pendingTask.reject() can be called within execute() method if the\n                    // task completed with error. However it may have also been called in\n                    // stop() or remove() methods (before or while being executed) so its\n                    // completed flag was already set. If so, abort here since next task\n                    // (if any) is already being executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));\n                    // Reject the task with the obtained error.\n                    reject(error);\n                    // Execute the next pending task (if any) unless stop() is running.\n                    if (!this.stopping) {\n                        const [nextPendingTask] = this.pendingTasks.values();\n                        // NOTE: During the reject() callback the user app may have interacted\n                        // with the queue. For instance, the app may have pushed a task while\n                        // the queue was empty so such a task is already being executed. If so,\n                        // don't execute it twice.\n                        if (nextPendingTask && !nextPendingTask.executedAt) {\n                            void this.execute(nextPendingTask);\n                        }\n                    }\n                }\n            };\n            // Append task to the queue.\n            this.pendingTasks.set(pendingTask.id, pendingTask);\n            // And execute it if this is the only task in the queue.\n            if (this.pendingTasks.size === 1) {\n                void this.execute(pendingTask);\n            }\n        });\n    }\n    stop() {\n        logger.debug('stop()');\n        this.stopping = true;\n        for (const pendingTask of this.pendingTasks.values()) {\n            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);\n            pendingTask.reject(new AwaitQueueStoppedError());\n        }\n        this.stopping = false;\n    }\n    remove(taskIdx) {\n        logger.debug(`remove() [taskIdx:${taskIdx}]`);\n        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n        if (!pendingTask) {\n            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);\n            return;\n        }\n        pendingTask.reject(new AwaitQueueRemovedTaskError());\n    }\n    dump() {\n        const now = Date.now();\n        let idx = 0;\n        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({\n            idx: idx++,\n            task: pendingTask.task,\n            name: pendingTask.name,\n            enqueuedTime: pendingTask.executedAt\n                ? pendingTask.executedAt - pendingTask.enqueuedAt\n                : now - pendingTask.enqueuedAt,\n            executionTime: pendingTask.executedAt\n                ? now - pendingTask.executedAt\n                : 0\n        }));\n    }\n    async execute(pendingTask) {\n        logger.debug(`execute() [name:${pendingTask.name}]`);\n        if (pendingTask.executedAt) {\n            throw new Error('task already being executed');\n        }\n        pendingTask.executedAt = Date.now();\n        try {\n            const result = await pendingTask.task();\n            // Resolve the task with its resolved result (if any).\n            pendingTask.resolve(result);\n        }\n        catch (error) {\n            // Reject the task with its rejected error.\n            pendingTask.reject(error);\n        }\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsa0NBQWtDLEdBQUcsOEJBQThCO0FBQ3hGLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9rZW1vbi1nYW1lLWV0aGluZGlhLTEvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanM/NTE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdhaXRRdWV1ZSA9IGV4cG9ydHMuQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IgPSBleHBvcnRzLkF3YWl0UXVldWVTdG9wcGVkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoKTtcbi8qKlxuICogQ3VzdG9tIEVycm9yIGRlcml2ZWQgY2xhc3MgdXNlZCB0byByZWplY3QgcGVuZGluZyB0YXNrcyBvbmNlIHN0b3AoKSBtZXRob2RcbiAqIGhhcyBiZWVuIGNhbGxlZC5cbiAqL1xuY2xhc3MgQXdhaXRRdWV1ZVN0b3BwZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ0F3YWl0UXVldWUgc3RvcHBlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXdhaXRRdWV1ZVN0b3BwZWRFcnJvcic7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXdhaXRRdWV1ZVN0b3BwZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF3YWl0UXVldWVTdG9wcGVkRXJyb3IgPSBBd2FpdFF1ZXVlU3RvcHBlZEVycm9yO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgZGVyaXZlZCBjbGFzcyB1c2VkIHRvIHJlamVjdCBwZW5kaW5nIHRhc2tzIG9uY2UgcmVtb3ZlVGFzaygpXG4gKiBtZXRob2QgaGFzIGJlZW4gY2FsbGVkLlxuICovXG5jbGFzcyBBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgPz8gJ0F3YWl0UXVldWUgdGFzayByZW1vdmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvcic7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvciA9IEF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yO1xuY2xhc3MgQXdhaXRRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFF1ZXVlIG9mIHBlbmRpbmcgdGFza3MgKG1hcCBvZiBQZW5kaW5nVGFza3MgaW5kZXhlZCBieSBpZCkuXG4gICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBJbmNyZW1lbnRpbmcgUGVuZGluZ1Rhc2sgaWQuXG4gICAgICAgIHRoaXMubmV4dFRhc2tJZCA9IDA7XG4gICAgICAgIC8vIFdoZXRoZXIgc3RvcCgpIG1ldGhvZCBpcyBzdG9wcGluZyBhbGwgcGVuZGluZyB0YXNrcy5cbiAgICAgICAgdGhpcy5zdG9wcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1Rhc2tzLnNpemU7XG4gICAgfVxuICAgIGFzeW5jIHB1c2godGFzaywgbmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSA/PyB0YXNrLm5hbWU7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgcHVzaCgpIFtuYW1lOiR7bmFtZX1dYCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGFzayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2l2ZW4gdGFzayBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXNrLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5uZXh0VGFza0lkKyssXG4gICAgICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGVucXVldWVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgZXhlY3V0ZWRBdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nVGFzay5yZXNvbHZlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGV4ZWN1dGUoKSBtZXRob2QuIFNpbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUoKSB3YXMgY2FsbGVkIGl0IG1lYW5zIHRoYXQgdGhlIHRhc2sgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGUgdGFzayBtYXkgaGF2ZSBiZWVuIHN0b3BwZWQgYmVmb3JlIGl0IGNvbXBsZXRlZCAodmlhXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AoKSBvciByZW1vdmUoKSkgc28gaXRzIGNvbXBsZXRlZCBmbGFnIHdhcyBhbHJlYWR5IHNldC4gSWYgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGUgY2FzZSwgYWJvcnQgaGVyZSBzaW5jZSBuZXh0IHRhc2sgKGlmIGFueSkgaXMgYWxyZWFkeSBiZWluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUYXNrLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUYXNrLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGFzayBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHBlbmRpbmdUYXNrLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGByZXNvbHZpbmcgdGFzayBbbmFtZToke3BlbmRpbmdUYXNrLm5hbWV9XWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXNrIHdpdGggdGhlIG9idGFpbmVkIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBuZXh0IHBlbmRpbmcgdGFzayAoaWYgYW55KS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW25leHRQZW5kaW5nVGFza10gPSB0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogRHVyaW5nIHRoZSByZXNvbHZlKCkgY2FsbGJhY2sgdGhlIHVzZXIgYXBwIG1heSBoYXZlIGludGVyYWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgcXVldWUuIEZvciBpbnN0YW5jZSwgdGhlIGFwcCBtYXkgaGF2ZSBwdXNoZWQgYSB0YXNrIHdoaWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSB3YXMgZW1wdHkgc28gc3VjaCBhIHRhc2sgaXMgYWxyZWFkeSBiZWluZyBleGVjdXRlZC4gSWYgc28sXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgaXQgdHdpY2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UGVuZGluZ1Rhc2sgJiYgIW5leHRQZW5kaW5nVGFzay5leGVjdXRlZEF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZXhlY3V0ZShuZXh0UGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWplY3Q6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nVGFzay5yZWplY3QoKSBjYW4gYmUgY2FsbGVkIHdpdGhpbiBleGVjdXRlKCkgbWV0aG9kIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXNrIGNvbXBsZXRlZCB3aXRoIGVycm9yLiBIb3dldmVyIGl0IG1heSBoYXZlIGFsc28gYmVlbiBjYWxsZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCgpIG9yIHJlbW92ZSgpIG1ldGhvZHMgKGJlZm9yZSBvciB3aGlsZSBiZWluZyBleGVjdXRlZCkgc28gaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBmbGFnIHdhcyBhbHJlYWR5IHNldC4gSWYgc28sIGFib3J0IGhlcmUgc2luY2UgbmV4dCB0YXNrXG4gICAgICAgICAgICAgICAgICAgIC8vIChpZiBhbnkpIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVGFzay5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVGFzay5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRhc2sgZnJvbSB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZShwZW5kaW5nVGFzay5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgcmVqZWN0aW5nIHRhc2sgW25hbWU6JHtwZW5kaW5nVGFzay5uYW1lfV06ICVzYCwgU3RyaW5nKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCB0aGUgdGFzayB3aXRoIHRoZSBvYnRhaW5lZCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgbmV4dCBwZW5kaW5nIHRhc2sgKGlmIGFueSkgdW5sZXNzIHN0b3AoKSBpcyBydW5uaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtuZXh0UGVuZGluZ1Rhc2tdID0gdGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBEdXJpbmcgdGhlIHJlamVjdCgpIGNhbGxiYWNrIHRoZSB1c2VyIGFwcCBtYXkgaGF2ZSBpbnRlcmFjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBxdWV1ZS4gRm9yIGluc3RhbmNlLCB0aGUgYXBwIG1heSBoYXZlIHB1c2hlZCBhIHRhc2sgd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSB3YXMgZW1wdHkgc28gc3VjaCBhIHRhc2sgaXMgYWxyZWFkeSBiZWluZyBleGVjdXRlZC4gSWYgc28sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBleGVjdXRlIGl0IHR3aWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQZW5kaW5nVGFzayAmJiAhbmV4dFBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZXhlY3V0ZShuZXh0UGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFwcGVuZCB0YXNrIHRvIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldChwZW5kaW5nVGFzay5pZCwgcGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgLy8gQW5kIGV4ZWN1dGUgaXQgaWYgdGhpcyBpcyB0aGUgb25seSB0YXNrIGluIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdUYXNrcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmV4ZWN1dGUocGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wKCknKTtcbiAgICAgICAgdGhpcy5zdG9wcGluZyA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgcGVuZGluZ1Rhc2sgb2YgdGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zyhgc3RvcCgpIHwgc3RvcHBpbmcgdGFzayBbbmFtZToke3BlbmRpbmdUYXNrLm5hbWV9XWApO1xuICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVqZWN0KG5ldyBBd2FpdFF1ZXVlU3RvcHBlZEVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlKHRhc2tJZHgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGByZW1vdmUoKSBbdGFza0lkeDoke3Rhc2tJZHh9XWApO1xuICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpW3Rhc2tJZHhdO1xuICAgICAgICBpZiAoIXBlbmRpbmdUYXNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYHN0b3AoKSB8IG5vIHRhc2sgd2l0aCBnaXZlbiBpZHggW3Rhc2tJZHg6JHt0YXNrSWR4fV1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QobmV3IEF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yKCkpO1xuICAgIH1cbiAgICBkdW1wKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpLm1hcCgocGVuZGluZ1Rhc2spID0+ICh7XG4gICAgICAgICAgICBpZHg6IGlkeCsrLFxuICAgICAgICAgICAgdGFzazogcGVuZGluZ1Rhc2sudGFzayxcbiAgICAgICAgICAgIG5hbWU6IHBlbmRpbmdUYXNrLm5hbWUsXG4gICAgICAgICAgICBlbnF1ZXVlZFRpbWU6IHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXRcbiAgICAgICAgICAgICAgICA/IHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQgLSBwZW5kaW5nVGFzay5lbnF1ZXVlZEF0XG4gICAgICAgICAgICAgICAgOiBub3cgLSBwZW5kaW5nVGFzay5lbnF1ZXVlZEF0LFxuICAgICAgICAgICAgZXhlY3V0aW9uVGltZTogcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdFxuICAgICAgICAgICAgICAgID8gbm93IC0gcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdFxuICAgICAgICAgICAgICAgIDogMFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGUocGVuZGluZ1Rhc2spIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBleGVjdXRlKCkgW25hbWU6JHtwZW5kaW5nVGFzay5uYW1lfV1gKTtcbiAgICAgICAgaWYgKHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBhbHJlYWR5IGJlaW5nIGV4ZWN1dGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwZW5kaW5nVGFzay50YXNrKCk7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXNrIHdpdGggaXRzIHJlc29sdmVkIHJlc3VsdCAoaWYgYW55KS5cbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlamVjdCB0aGUgdGFzayB3aXRoIGl0cyByZWplY3RlZCBlcnJvci5cbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF3YWl0UXVldWUgPSBBd2FpdFF1ZXVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/awaitqueue/lib/index.js\n");

/***/ })

};
;