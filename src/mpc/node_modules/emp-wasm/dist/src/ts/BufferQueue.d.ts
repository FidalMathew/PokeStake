/**
 * A queue for managing buffered data that allows pushing and popping of data chunks.
 */
export default class BufferQueue {
    private buffer;
    private bufferStart;
    private bufferEnd;
    private pendingPops;
    private pendingPopsResolvers;
    private closed;
    constructor(initialCapacity?: number);
    /**
     * Ensures that the buffer has enough capacity to accommodate additional bytes.
     * If not, it resizes the buffer by doubling its current size.
     * @param additionalLength - The additional length of data to be accommodated.
     */
    private _ensureCapacity;
    /**
     * Pushes new data into the buffer and resolves any pending pop requests if possible.
     * @param data - The data to push into the buffer (must be a Uint8Array).
     */
    push(data: Uint8Array): void;
    /**
     * Pops a specified number of bytes from the buffer.
     * Returns a Promise that resolves with a Uint8Array of the requested length.
     * @param len - The number of bytes to pop from the buffer.
     * @returns A promise resolving with the popped data as a Uint8Array.
     */
    pop(len: number): Promise<Uint8Array>;
    /**
     * Closes the buffer queue, preventing any further data from being pushed.
     */
    close(): void;
    /**
     * Checks if the buffer queue is closed.
     * @returns True if the buffer queue is closed, false otherwise.
     */
    isClosed(): boolean;
    /**
     * Resolves pending pop requests if enough data is available in the buffer.
     */
    private _resolvePendingPops;
    private _rejectPendingPops;
    /**
     * Compacts the buffer by resetting the start and end pointers if all data has been consumed.
     */
    private _compactBuffer;
}
//# sourceMappingURL=BufferQueue.d.ts.map