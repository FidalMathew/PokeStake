import { EventEmitter } from 'ee-typed';
import Peer from 'peerjs';
import Cipher from './Cipher';
import Key from './Key';
export default class RtcPairSocket extends EventEmitter {
    pairingCode;
    party;
    conn;
    closed = false;
    cipher;
    alicePeerId;
    bobPeerId;
    peerId;
    constructor(pairingCode, party) {
        super();
        this.pairingCode = pairingCode;
        this.party = party;
        const key = Key.fromSeed(pairingCode);
        this.cipher = new Cipher(key);
        const idPrefix = `rtc-pair-socket-${Key.fromSeed(key.data).base58()}`;
        this.alicePeerId = `${idPrefix}-alice`;
        this.bobPeerId = `${idPrefix}-bob`;
        this.peerId = party === 'alice' ? this.alicePeerId : this.bobPeerId;
        this.connect().catch((err) => this.emit('error', ensureError(err)));
    }
    async connect() {
        const peer = new Peer(this.peerId);
        await new Promise((resolve, reject) => {
            peer.on('open', resolve);
            peer.on('error', reject);
        });
        let conn;
        if (this.party === 'alice') {
            const connPromise = new Promise(resolve => peer.on('connection', resolve));
            const notifyConn = peer.connect(this.bobPeerId);
            notifyConn.on('open', () => notifyConn.close());
            conn = await connPromise;
        }
        else {
            conn = peer.connect(this.alicePeerId, { reliable: true });
            await new Promise((resolve, reject) => {
                conn.on('open', resolve);
                conn.on('error', reject);
                peer.on('connection', (notifyConn) => {
                    notifyConn.close();
                    conn.close();
                    conn = peer.connect(this.alicePeerId, { reliable: true });
                    conn.on('open', resolve);
                    conn.on('error', reject);
                });
            });
        }
        if (this.closed) {
            conn.close();
            return;
        }
        this.conn = conn;
        conn.on('data', (data) => {
            let buf;
            if (data instanceof ArrayBuffer) {
                buf = new Uint8Array(data);
            }
            else if (data instanceof Uint8Array) {
                buf = data;
            }
            else {
                this.emit('error', new Error('Received unrecognized data type'));
                return;
            }
            this.emit('message', this.cipher.decrypt(buf));
        });
        conn.on('error', (err) => {
            this.emit('error', err);
        });
        conn.on('close', () => {
            this.close();
        });
        if (!conn.reliable) {
            // covers the unlikely case where the other side used reliable: false
            conn.close();
            throw new Error('Connection is not reliable');
        }
        this.emit('open');
    }
    send(data) {
        if (!this.conn) {
            throw new Error('Connection not established');
        }
        this.conn.send(this.cipher.encrypt(data));
    }
    close() {
        if (!this.closed) {
            this.conn?.close();
            this.conn = undefined;
            this.closed = true;
            this.emit('close');
        }
    }
    isClosed() {
        return this.closed;
    }
    getKey() {
        return this.cipher.key;
    }
}
function ensureError(err) {
    return err instanceof Error ? err : new Error(JSON.stringify(err));
}
//# sourceMappingURL=RtcPairSocket.js.map